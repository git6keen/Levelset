"""
Prototype 3 — single-folder app
Now with /api/tasks and /api/checklists endpoints.
"""
# === SECTION: imports
from fastapi import FastAPI, HTTPException, Query
from fastapi.responses import JSONResponse, PlainTextResponse
from fastapi.middleware.cors import CORSMiddleware
from typing import Any, Dict, Optional

import uvicorn

from trace_utils import log_event, get_events_snapshot
from db_utils import get_conn, rows_to_dicts
from printer_formatter import format_checklist
from features import FEATURES

# === SECTION: app_setup
app = FastAPI(title="Prototype 3")

# CORS for Vite dev (localhost:5173)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5173", "http://127.0.0.1:5173"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# >>> RUNBOOK (last_updated=api_v1):
# uvicorn main:app --reload
# curl http://127.0.0.1:8000/healthz
# curl http://127.0.0.1:8000/dev/trace
# curl "http://127.0.0.1:8000/api/tasks?sort=priority"
# curl -X POST http://127.0.0.1:8000/api/tasks -H "Content-Type: application/json" -d "{\"title\":\"Demo\",\"priority\":3,\"xp\":10,\"coins\":1}"

# === SECTION: routes.health
@app.get("/healthz")
def healthz() -> Dict[str, Any]:
    log_event("HEALTHZ", {"ok": True})
    return {"ok": True}

# === SECTION: routes.dev_trace
@app.get("/dev/trace", response_class=PlainTextResponse)
def dev_trace() -> str:
    events = get_events_snapshot()
    if not events:
        return "No events yet."
    lines = []
    for e in events:
        lines.append(f"{e['ts']} | {e['name']} | {e.get('payload',{})}")
    return "\n".join(lines) + "\n"

# === SECTION: routes.tasks
@app.get("/api/tasks")
def list_tasks(
    q: Optional[str] = Query(None),
    priority: Optional[int] = Query(None, ge=1, le=5),
    sort: str = Query("priority"),  # priority|xp|coins|title
):
    order = {
        "priority": "priority ASC, task_id ASC",
        "xp": "xp_reward DESC, task_id DESC",
        "coins": "coin_reward DESC, task_id DESC",
        "title": "title COLLATE NOCASE ASC, task_id ASC",
    }.get(sort, "priority ASC, task_id ASC")

    params = []
    where = ["is_active = 1"]
    if q:
        where.append("title LIKE ?")
        params.append(f"%{q}%")
    if priority is not None:
        where.append("priority = ?")
        params.append(priority)
    where_sql = " AND ".join(where)

    with get_conn() as conn:
        rows = conn.execute(
            f"""
            SELECT task_id, title, priority, xp_reward AS xp, coin_reward AS coins
            FROM tasks
            WHERE {where_sql}
            ORDER BY {order}
            """,
            params,
        ).fetchall()
        return rows_to_dicts(rows)

@app.post("/api/tasks")
def create_task(body: Dict[str, Any]):
    title = (body.get("title") or "").strip()
    if not title:
        raise HTTPException(400, "title is required")
    priority = int(body.get("priority") or 3)
    if priority < 1 or priority > 5:
        raise HTTPException(400, "priority must be 1..5")
    xp = int(body.get("xp") or 0)
    coins = int(body.get("coins") or 0)

    with get_conn() as conn:
        cur = conn.execute(
            """
            INSERT INTO tasks(user_id, title, description, category_id, priority, xp_reward, coin_reward)
            VALUES(NULL, ?, NULL, NULL, ?, ?, ?)
            """,
            (title, priority, xp, coins),
        )
        task_id = cur.lastrowid
        row = conn.execute(
            "SELECT task_id, title, priority, xp_reward AS xp, coin_reward AS coins FROM tasks WHERE task_id=?",
            (task_id,),
        ).fetchone()
    log_event("TASK_CREATE", {"task_id": task_id})
    return rows_to_dicts([row])[0]

# === SECTION: routes.checklists
@app.get("/api/checklists")
def list_checklists(
    q: Optional[str] = Query(None),
    category: Optional[str] = Query(None),
    sort: str = Query("name"),  # name|items
):
    order = {
        "name": "c.name COLLATE NOCASE ASC",
        "items": "items_count DESC, c.name COLLATE NOCASE ASC",
    }.get(sort, "c.name COLLATE NOCASE ASC")

    params = []
    where = ["1=1"]
    if q:
        where.append("c.name LIKE ?")
        params.append(f"%{q}%")
    if category:
        where.append("COALESCE(c.category,'') = ?")
        params.append(category)

    where_sql = " AND ".join(where)

    with get_conn() as conn:
        rows = conn.execute(
            f"""
            SELECT
              c.checklist_id AS id,
              c.name,
              c.category,
              COUNT(i.item_id) AS items
            FROM checklists c
            LEFT JOIN checklist_items i ON i.checklist_id = c.checklist_id
            WHERE {where_sql}
            GROUP BY c.checklist_id
            ORDER BY {order}
            """,
            params,
        ).fetchall()
        return rows_to_dicts(rows)

@app.post("/api/checklists")
def create_checklist(body: Dict[str, Any]):
    name = (body.get("name") or "").strip()
    if not name:
        raise HTTPException(400, "name is required")
    category = body.get("category")
    with get_conn() as conn:
        cur = conn.execute(
            "INSERT INTO checklists(user_id, name, category) VALUES(NULL, ?, ?)",
            (name, category),
        )
        cid = cur.lastrowid
        row = conn.execute(
            """
            SELECT c.checklist_id AS id, c.name, c.category,
                   (SELECT COUNT(*) FROM checklist_items x WHERE x.checklist_id = c.checklist_id) AS items
            FROM checklists c WHERE c.checklist_id=?
            """,
            (cid,),
        ).fetchone()
    log_event("CHECKLIST_CREATE", {"checklist_id": cid})
    return rows_to_dicts([row])[0]

# Optional: print endpoint using printer formatter (returns text/plain)
@app.get("/api/checklists/{checklist_id}/print", response_class=PlainTextResponse)
def print_checklist(checklist_id: int):
    with get_conn() as conn:
        head = conn.execute(
            "SELECT name FROM checklists WHERE checklist_id=?",
            (checklist_id,),
        ).fetchone()
        if not head:
            raise HTTPException(404, "checklist not found")
        items = conn.execute(
            "SELECT text, completed FROM checklist_items WHERE checklist_id=? ORDER BY position, item_id",
            (checklist_id,),
        ).fetchall()
    title = head["name"]
    tuples = [(r["text"], bool(r["completed"])) for r in items]
    return format_checklist(title, tuples, width=40)

if __name__ == "__main__":
    uvicorn.run("main:app", host="127.0.0.1", port=8000, reload=True)
