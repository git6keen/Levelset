/* ================================================================
   server.ts — single entrypoint (Express + better-sqlite3)
   Prototype 3 — Long-File Modularity Rules applied
================================================================ */

import express from "express";
import cors from "cors";
import Database from "better-sqlite3";
import * as path from "node:path";
import * as fs from "node:fs";

// Optional fetch polyfill (harmless on Node =18)
try {
  // @ts-ignore
  if (!(globalThis as any).fetch) {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const { fetch: undiciFetch } = require("undici");
    (globalThis as any).fetch = undiciFetch;
  }
} catch {}

/* === Chat adapter (LM Studio / OpenAI-compatible) ======================== */
import { chatOnce, chatStream } from "./adapter_lm"; // ensure adapter_lm.ts exists

// === SECTION: constants & bootstrap
const PORT = 8001;
const DB_PATH = "./app.db";

const db = new Database(DB_PATH);
db.pragma("journal_mode = WAL");
db.pragma("foreign_keys = ON");
function ensureJournalTable(): void {
  // Create table if missing
  const exists = !!db.prepare("SELECT name FROM sqlite_master WHERE type='table' AND name=?").get("journal_entries");
  if (!exists) {
    db.exec("CREATE TABLE IF NOT EXISTS journal_entries (entry_id INTEGER PRIMARY KEY, ts TEXT, text TEXT, mood INTEGER, energy INTEGER, stress INTEGER, tags TEXT);");
  }

  // Ensure required columns exist (some older tables may lack them)
  const info = db.prepare("PRAGMA table_info(journal_entries)").all() as Array<{name:string}>;
  const has = (n:string) => info.some(c => c.name === n);

  if (!has("ts"))     db.exec("ALTER TABLE journal_entries ADD COLUMN ts TEXT");
  if (!has("text"))   db.exec("ALTER TABLE journal_entries ADD COLUMN text TEXT");
  if (!has("mood"))   db.exec("ALTER TABLE journal_entries ADD COLUMN mood INTEGER");
  if (!has("energy")) db.exec("ALTER TABLE journal_entries ADD COLUMN energy INTEGER");
  if (!has("stress")) db.exec("ALTER TABLE journal_entries ADD COLUMN stress INTEGER");
  if (!has("tags"))   db.exec("ALTER TABLE journal_entries ADD COLUMN tags TEXT");

  // Create index on ts if possible
  const info2 = db.prepare("PRAGMA table_info(journal_entries)").all() as Array<{name:string}>;
  if (info2.some(c => c.name === "ts")) {
    db.exec("CREATE INDEX IF NOT EXISTS idx_journal_entries_ts ON journal_entries(ts)");
  }
}/** Ensure DB schema is compatible with current server expectations (idempotent). */
function ensureSchema(): void {
  const tableExists = (name: string): boolean =>
    !!db.prepare("SELECT name FROM sqlite_master WHERE type='table' AND name=?").get(name);

  const hasCol = (table: string, name: string): boolean => {
    const rows = db.prepare(`PRAGMA table_info(${table})`).all() as Array<{ name: string }>;
    return rows.some((r) => r.name === name);
  };

  db.transaction(() => {
    // --- journal_entries (ensure table before any use)
    db.exec("CREATE TABLE IF NOT EXISTS journal_entries (entry_id INTEGER PRIMARY KEY, ts TEXT, text TEXT, mood INTEGER, energy INTEGER, stress INTEGER, tags TEXT);");
    db.exec("CREATE INDEX IF NOT EXISTS idx_journal_entries_ts ON journal_entries(ts)");
    // --- journal_entries (ensure table before any use)
// index for date range lookups
    db.exec("CREATE INDEX IF NOT EXISTS idx_journal_entries_ts ON journal_entries(ts)");
    // --- checklist_items.position (older DBs may miss it)
    if (tableExists("checklist_items") && !hasCol("checklist_items", "position")) {
      db.exec("ALTER TABLE checklist_items ADD COLUMN position INTEGER");
    }
    // Backfill (safe if column already exists)
    db.exec("UPDATE checklist_items SET position = COALESCE(position, item_id)");

    // --- tasks optional columns
    if (tableExists("tasks")) {
      if (!hasCol("tasks", "xp_reward")) db.exec("ALTER TABLE tasks ADD COLUMN xp_reward INTEGER DEFAULT 0");
      if (!hasCol("tasks", "coin_reward")) db.exec("ALTER TABLE tasks ADD COLUMN coin_reward INTEGER DEFAULT 0");
      if (!hasCol("tasks", "is_active")) db.exec("ALTER TABLE tasks ADD COLUMN is_active INTEGER DEFAULT 1");
      if (!hasCol("tasks", "created_at")) db.exec("ALTER TABLE tasks ADD COLUMN created_at TEXT");
      if (!hasCol("tasks", "category_id")) db.exec("ALTER TABLE tasks ADD COLUMN category_id INTEGER");
    }

    // --- checklists.created_at
    if (tableExists("checklists") && !hasCol("checklists", "created_at")) {
      db.exec("ALTER TABLE checklists ADD COLUMN created_at TEXT");
    }

	// --- journal_entries (if not exists)
	db.exec(`
 	CREATE TABLE IF NOT EXISTS journal_entries (
    	entry_id   INTEGER PRIMARY KEY,
    	ts         TEXT,
    	text       TEXT,
    	mood       INTEGER,
    	energy     INTEGER,
    	stress     INTEGER,
    	tags       TEXT
  	);
`);


    // --- task_categories (create fresh OR upgrade existing)
    if (!tableExists("task_categories")) {
      db.exec(`
        CREATE TABLE task_categories (
          category_id INTEGER PRIMARY KEY,
          name        TEXT NOT NULL,
          color       TEXT DEFAULT '#64748b',
          position    INTEGER
        );
      `);
    } else {
      if (!hasCol("task_categories", "color")) db.exec("ALTER TABLE task_categories ADD COLUMN color TEXT DEFAULT '#64748b'");
      if (!hasCol("task_categories", "position")) db.exec("ALTER TABLE task_categories ADD COLUMN position INTEGER");
    }
    // Simple index that supports ORDER BY position, category_id
    db.exec("CREATE INDEX IF NOT EXISTS idx_task_categories_position ON task_categories(position, category_id)");

	// --- journal_entries (index for date range queries)
db.exec("CREATE INDEX IF NOT EXISTS idx_journal_entries_ts ON journal_entries(ts)");

  })();

  // [hotfix] migrate legacy task_categories.name (fixing earlier paste artifacts)
  try {
    if (tableExists("task_categories")) {
      const hasName = hasCol("task_categories", "name");
      const hasLegacy = hasCol("task_categories", "category_name");
      if (!hasName && hasLegacy) {
        db.exec("ALTER TABLE task_categories ADD COLUMN name TEXT");
        db.exec("UPDATE task_categories SET name = COALESCE(name, category_name)");
        console.log("[migrate] task_categories: copied category_name -> name");
      }
    }
  } catch (e: any) {
    console.warn("[migrate] task_categories hotfix failed:", e?.message || e);
  }
}
ensureJournalTable();
ensureSchema();

// Startup diagnostics
console.log("[startup] cwd =", process.cwd());
const RESOLVED_DB = path.resolve(DB_PATH);
console.log("[startup] db  =", RESOLVED_DB, fs.existsSync(RESOLVED_DB) ? "(exists)" : "(missing)");

// === SECTION: helpers
function row<T = any>(sql: string, ...args: any[]) {
  return db.prepare(sql).get(...args) as T;
}
function all<T = any>(sql: string, ...args: any[]) {
  return db.prepare(sql).all(...args) as T[];
}
function run(sql: string, ...args: any[]) {
  return db.prepare(sql).run(...args);
}
function ts() {
  const d = new Date();
  const pad = (n: number) => String(n).padStart(2, "0");
  return `${d.getFullYear()}${pad(d.getMonth() + 1)}${pad(d.getDate())}-${pad(d.getHours())}${pad(d.getMinutes())}${pad(
    d.getSeconds()
  )}`;
}

/* === SECTION: tools (server-executed abilities) =========================== */
type ToolResult = { ok: true; result?: any } | { ok: false; error: string };

const tools: Record<string, (args: any) => ToolResult> = {
  // tasks.create({ title, description?, priority?, category_id?, xp?, coins? })
  "tasks.create": (args: any): ToolResult => {
    try {
      const title = String(args?.title ?? "").trim();
      if (!title) return { ok: false, error: "title required" };
      const description = args?.description ?? null;
      const priority = args?.priority ?? 1;
      const category_id = args?.category_id ?? null;
      const xp = args?.xp ?? 0;
      const coins = args?.coins ?? 0;
      run(
        `INSERT INTO tasks(user_id, title, description, category_id, priority, xp_reward, coin_reward, is_active, created_at)
         VALUES (?,?,?,?,?,?,1,COALESCE(?, CURRENT_TIMESTAMP))`,
        title, description, (category_id==null? null : Number(category_id)),
        Number(priority), Number(xp), Number(coins), null
      );
      const id = row<{ id:number }>("SELECT last_insert_rowid() AS id")?.id;
      return { ok: true, result: { task_id: id } };
    } catch (e: any) { return { ok:false, error: e?.message ?? String(e) }; }
  },

  // journal.save({ text, mood, energy, stress, tags, ts? })
  "journal.save": (args: any): ToolResult => {
    try {
      const when = args?.ts || new Date().toISOString();
      const info = run(
        "INSERT INTO journal_entries(ts, text, mood, energy, stress, tags) VALUES (?,?,?,?,?,?)",
        when, String(args?.text ?? ""), Number(args?.mood ?? 0), Number(args?.energy ?? 0),
        Number(args?.stress ?? 0), String(args?.tags ?? "")
      );
      return { ok: true, result: { entry_id: info.lastInsertRowid } };
    } catch (e:any) { return { ok:false, error: e?.message ?? String(e) }; }  ,
  // checklists.addItem({ checklist_id, text })
  "checklists.addItem": (args: any): ToolResult => {
    try {
      const checklist_id = Number(args?.checklist_id ?? NaN);
      const text = String(args?.text ?? "").trim();
      if (!checklist_id || !isFinite(checklist_id)) return { ok:false, error:"checklist_id required" };
      if (!text) return { ok:false, error:"text required" };
      const maxPos = row<{ max:number }>("SELECT COALESCE(MAX(position),0) AS max FROM checklist_items WHERE checklist_id=?", checklist_id)?.max ?? 0;
      const info = run("INSERT INTO checklist_items(checklist_id, text, completed, position) VALUES (?,?,0,?)", checklist_id, text, maxPos + 1);
      return { ok:true, result:{ item_id: info.lastInsertRowid, position: maxPos + 1 } };
    } catch (e:any) {
      return { ok:false, error: e?.message ?? String(e) };
    }
  }
(name: string, args: any): ToolResult {
  const fn = tools[name];
  if (!fn) return { ok:false, error:`unknown tool: ${name}` };
  return fn(args);
}


// === SECTION: app
const app = express();
app.use(cors());
app.use(express.json());
// --- JSON error middleware (forces JSON instead of HTML on unhandled errors)
app.use((err: any, _req, res, _next) => {
  const msg = (err && err.message) ? err.message : String(err);
  console.error("[error]", msg);
  res.status(500).json({ error: msg });
});

// === SECTION: health
app.get("/healthz", (_req, res) => res.json({ ok: true }));
app.get("/dev/trace", (_req, res) => res.json({ ok: true, note: "stub" }));

/* === SECTION: TASK CATEGORIES (CRUD)
---------------------------------------------------- */
app.get("/api/task-categories", (_req, res) => {
  const rows = all<{ category_id: number; name: string; color?: string | null; position?: number | null }>(
    `SELECT category_id, COALESCE(name, category_name) AS name, COALESCE(color,'#64748b') AS color, position
     FROM task_categories
     ORDER BY COALESCE(position, category_id) ASC, category_id ASC`
  );
  res.json(rows);
});

/* === SECTION: JOURNAL =================================== */
app.post("/api/journal", (req, res) => {
  const { mood, energy, stress, tags, notes } = req.body;
  // insert into DB here
  res.json({ ok: true });
});
app.get("/api/journal", (req, res) => {
  // return latest journal entries
});


app.post("/api/task-categories", (req, res) => {
  const { name, color = "#64748b", position } = (req.body || {}) as { name?: string; color?: string; position?: number };
  if (!name || String(name).trim() === "") return res.status(400).json({ error: "Name required" });
  let pos = position;
  if (pos == null) {
    pos = row<{ max: number }>("SELECT COALESCE(MAX(position),0) AS max FROM task_categories")?.max ?? 0;
    pos = (pos || 0) + 1;
  }
  const info = run("INSERT INTO task_categories(name, color, position) VALUES (?,?,?)", String(name).trim(), String(color), Number(pos));
  res.status(201).json({ ok: true, category_id: info.lastInsertRowid });
});

app.patch("/api/task-categories/:id", (req, res) => {
  const id = Number(req.params.id);
  const cur = row("SELECT category_id FROM task_categories WHERE category_id=?", id);
  if (!cur) return res.status(404).json({ error: "Not found" });

  const { name, color, position } = (req.body || {}) as { name?: string; color?: string; position?: number };
  run(
    `UPDATE task_categories SET
        name     = COALESCE(?, name),
        color    = COALESCE(?, color),
        position = COALESCE(?, position)
      WHERE category_id=?`,
    name ?? null,
    color ?? null,
    position == null ? null : Number(position),
    id
  );
  res.json({ ok: true });
});

app.delete("/api/task-categories/:id", (req, res) => {
  const id = Number(req.params.id);
  const inUse = row<{ c: number }>("SELECT COUNT(*) c FROM tasks WHERE category_id=?", id)?.c ?? 0;
  if (inUse > 0) return res.status(409).json({ error: "Category in use by tasks" });
  run("DELETE FROM task_categories WHERE category_id=?", id);
  res.json({ ok: true });
});

/* === SECTION: TASKS
   DB columns: task_id, title, description, category_id, priority, xp_reward, coin_reward, created_at, is_active
   Client expects: task_id, title, description, priority, xp, coins, created_at, category_id
---------------------------------------------------- */
app.get("/api/tasks", (req, res) => {
  const { q, priority, sort, category_id } = req.query as {
    q?: string;
    priority?: string;
    sort?: "priority" | "title" | "created_at";
    category_id?: string;
  };
  const clauses: string[] = ["COALESCE(t.is_active,1)=1"];
  const params: any[] = [];
  if (q) {
    clauses.push("t.title LIKE ?");
    params.push(`%${q}%`);
  }
  if (priority != null) {
    clauses.push("t.priority = ?");
    params.push(Number(priority));
  }
  if (category_id != null && category_id !== "") {
    clauses.push("t.category_id = ?");
    params.push(Number(category_id));
  }
  const where = `WHERE ${clauses.join(" AND ")}`;

  const sortCol = sort === "title" ? "LOWER(t.title)" : sort === "priority" ? "t.priority" : "COALESCE(t.created_at, '')";
  const desc = sort === "title" ? "" : "DESC";

  const rows = all<{
    task_id: number;
    title: string;
    description?: string | null;
    priority: number;
    xp_reward: number;
    coin_reward: number;
    created_at?: string | null;
    category_id?: number | null;
  }>(
    `
    SELECT
      t.task_id, t.title, t.description, t.priority,
      COALESCE(t.xp_reward,0)  AS xp_reward,
      COALESCE(t.coin_reward,0) AS coin_reward,
      t.created_at,
      t.category_id
    FROM tasks t
    ${where}
    ORDER BY ${sortCol} ${desc}, t.task_id DESC
  `,
    ...params
  ).map((r) => ({
    task_id: r.task_id,
    title: r.title,
    description: r.description ?? null,
    priority: r.priority,
    xp: r.xp_reward ?? 0,
    coins: r.coin_reward ?? 0,
    created_at: r.created_at ?? null,
    category_id: r.category_id ?? null,
  }));

  res.json(rows);
});

app.post("/api/tasks", (req, res) => {
  const { title, description = null, priority = 1, xp = 0, coins = 0, category_id = null } = req.body || {};
  if (!title || String(title).trim() === "") return res.status(400).json({ error: "Title required" });
  run(
    `INSERT INTO tasks(user_id, title, description, category_id, priority, xp_reward, coin_reward, is_active, created_at)
     VALUES (?,?,?,?,?,?,1,COALESCE(?, CURRENT_TIMESTAMP))`,
    String(title).trim(),
    description,
    category_id == null ? null : Number(category_id),
    Number(priority),
    Number(xp ?? 0),
    Number(coins ?? 0),
    null
  );
  res.status(204).end();
});

app.patch("/api/tasks/:id", (req, res) => {
  const id = Number(req.params.id);
  const { title, description = null, priority, xp, coins, category_id } = req.body || {};
  const cur = row("SELECT task_id FROM tasks WHERE task_id=?", id);
  if (!cur) return res.status(404).json({ error: "Not found" });
  run(
    `
    UPDATE tasks SET
      title        = COALESCE(?, title),
      description  = ?,
      category_id  = COALESCE(?, category_id),
      priority     = COALESCE(?, priority),
      xp_reward    = COALESCE(?, xp_reward),
      coin_reward  = COALESCE(?, coin_reward)
    WHERE task_id = ?
  `,
    title ?? null,
    description,
    category_id == null ? null : Number(category_id),
    priority ?? null,
    xp ?? null,
    coins ?? null,
    id
  );
  res.status(204).end();
});

app.delete("/api/tasks/:id", (req, res) => {
  const id = Number(req.params.id);
  run("DELETE FROM tasks WHERE task_id=?", id);
  res.json({ ok: true });
});

app.post("/api/tasks/:id/complete", (req, res) => {
  const id = Number(req.params.id);
  const cur = row("SELECT task_id FROM tasks WHERE task_id=?", id);
  if (!cur) return res.status(404).json({ error: "Not found" });
  run("UPDATE tasks SET is_active=0 WHERE task_id=?", id);
  res.json({ ok: true, completion_id: Date.now() });
});

/* === SECTION: CHECKLISTS
---------------------------------------------------- */
app.get("/api/checklists", (req, res) => {
  const { q, category, sort } = req.query as { q?: string; category?: string; sort?: "name" | "created_at" };
  const clauses: string[] = [];
  const params: any[] = [];
  if (q) {
    clauses.push("c.name LIKE ?");
    params.push(`%${q}%`);
  }
  if (category) {
    clauses.push("c.category = ?");
    params.push(category);
  }
  const where = clauses.length ? `WHERE ${clauses.join(" AND ")}` : "";
  const order = sort === "name" ? "LOWER(c.name) ASC" : "COALESCE(c.created_at,'') DESC, c.checklist_id DESC";
  const rows = all<{
    checklist_id: number;
    name: string;
    category?: string | null;
    created_at?: string | null;
    items: number;
  }>(
    `
    SELECT
      c.checklist_id,
      c.name,
      c.category,
      c.created_at,
      COALESCE((SELECT COUNT(*) FROM checklist_items i WHERE i.checklist_id=c.checklist_id),0) AS items
    FROM checklists c
    ${where}
    ORDER BY ${order}
  `,
    ...params
  ).map((r) => ({
    id: r.checklist_id,
    name: r.name,
    category: r.category ?? null,
    created_at: r.created_at ?? null,
    items: r.items ?? 0,
  }));
  res.json(rows);
});

app.post("/api/checklists", (req, res) => {
  const { name, category = null } = req.body || {};
  if (!name || String(name).trim() === "") return res.status(400).json({ error: "Name required" });
  run("INSERT INTO checklists(name, category, created_at) VALUES(?,?,COALESCE(?, CURRENT_TIMESTAMP))", String(name).trim(), category, null);
  res.status(204).end();
});

app.get("/api/checklists/:id/items", (req, res) => {
  const id = Number(req.params.id);
  const rows = all<{ item_id: number; checklist_id: number; text: string; completed: 0 | 1; position?: number | null }>(
    `
    SELECT
      i.item_id, i.checklist_id, i.text,
      COALESCE(i.completed,0) AS completed,
      COALESCE(i.position, i.item_id) AS position
    FROM checklist_items i
    WHERE i.checklist_id=?
    ORDER BY COALESCE(i.position, i.item_id) ASC, i.item_id ASC
  `,
    id
  ).map((r) => ({
    id: r.item_id,
    checklist_id: r.checklist_id,
    text: r.text,
    done: (r.completed ? 1 : 0) as 0 | 1,
    position: r.position ?? undefined,
  }));
  res.json(rows);
});

app.post("/api/checklists/:id/items", (req, res) => {
  const id = Number(req.params.id);
  const { text } = req.body || {};
  if (!text || String(text).trim() === "") return res.status(400).json({ error: "Text required" });
  const maxPos = row<{ max: number }>("SELECT COALESCE(MAX(position),0) AS max FROM checklist_items WHERE checklist_id=?", id)?.max ?? 0;
  run("INSERT INTO checklist_items(checklist_id, text, completed, position) VALUES (?,?,0,?)", id, String(text).trim(), maxPos + 1);
  res.status(204).end();
});

app.patch("/api/checklists/:id/items/:itemId/toggle", (req, res) => {
  const id = Number(req.params.id);
  const itemId = Number(req.params.itemId);
  const cur = row<{ completed?: 0 | 1 }>("SELECT completed FROM checklist_items WHERE item_id=? AND checklist_id=?", itemId, id);
  if (!cur) return res.status(404).json({ error: "Not found" });
  const next = cur.completed === 1 ? 0 : 1;
  run("UPDATE checklist_items SET completed=? WHERE item_id=? AND checklist_id=?", next, itemId, id);
  res.json({ ok: true, done: next });
});

app.delete("/api/checklists/:id/items/:itemId", (req, res) => {
  const id = Number(req.params.id);
  const itemId = Number(req.params.itemId);
  run("DELETE FROM checklist_items WHERE item_id=? AND checklist_id=?", itemId, id);
  res.json({ ok: true });
});

app.patch("/api/checklists/:id/items/reorder", (req, res) => {
  const id = Number(req.params.id);
  const { order } = req.body as { order: number[] };
  if (!Array.isArray(order)) return res.status(400).json({ error: "order array required" });
  const upd = db.prepare("UPDATE checklist_items SET position=? WHERE item_id=? AND checklist_id=?");
  const tx = db.transaction((ids: number[]) => {
    ids.forEach((itemId, idx) => upd.run(idx + 1, itemId, id));
  });
  tx(order);
  res.json({ ok: true });
});

app.get("/api/checklists/:id/print", (req, res) => {
  const id = Number(req.params.id);
  const list = row<{ checklist_id: number; name: string }>("SELECT checklist_id, name FROM checklists WHERE checklist_id=?", id);
  if (!list) return res.status(404).send("Not found");
  const items = all<{ text: string; completed: 0 | 1 }>(
    "SELECT text, COALESCE(completed,0) AS completed FROM checklist_items WHERE checklist_id=? ORDER BY COALESCE(position,item_id), item_id",
    id
  );
/* === SECTION: JOURNAL (recent window) ===================================== */
app.get("/api/journal/recent", (req, res) => {
  // Defaults: previous 30 days ending now
  const now = new Date();
  const to = req.query.to ? new Date(String(req.query.to)) : now;
  const from = req.query.from ? new Date(String(req.query.from)) : new Date(to.getTime() - 30*24*60*60*1000);

  const fromISO = from.toISOString();
  const toISO = to.toISOString();

  const rows = all<{
    entry_id:number; ts:string; text:string; mood:number|null; energy:number|null; stress:number|null; tags:string|null;
  }>(`
    SELECT entry_id, ts, text, mood, energy, stress, tags
    FROM journal_entries
    WHERE ts BETWEEN ? AND ?
    ORDER BY ts DESC, entry_id DESC
  `, fromISO, toISO).map(r => ({
    id: r.entry_id,
    ts: r.ts,
    text: r.text,
    mood: r.mood ?? 0,
    energy: r.energy ?? 0,
    stress: r.stress ?? 0,
    tags: r.tags ?? ""
  }));

  res.json({ from: fromISO, to: toISO, rows });
});

  const lines = [
    `Checklist: ${list.name}`,
    `Generated: ${new Date().toISOString()}`,
    "",
    ...items.map((it, i) => `[${it.completed ? "x" : " "}] ${i + 1}. ${it.text}`),
  ];
  const txt = lines.join("\n");
  try {
    fs.writeFileSync("last_print.txt", txt, "utf-8");
  } catch {}
  res.type("text/plain").send(txt);
});

/* === SECTION: ADMIN (exports, backup, clear, diagnostics)
---------------------------------------------------- */
app.get("/api/admin/info", (_req, res) => {
  const journal = db.pragma("journal_mode", { simple: true }) as unknown as string;
  const user_version = db.pragma("user_version", { simple: true }) as unknown as number;
  res.json({
    cwd: process.cwd(),
    db_path: RESOLVED_DB,
    journal_mode: journal,
    wal: String(journal).toUpperCase().includes("WAL"),
    schema_version: user_version ?? null,
  });
});

app.get("/api/admin/counts", (_req, res) => {
  const tasks = row<{ c: number }>("SELECT COUNT(*) c FROM tasks")?.c ?? 0;
  const checklists = row<{ c: number }>("SELECT COUNT(*) c FROM checklists")?.c ?? 0;
  const items = row<{ c: number }>("SELECT COUNT(*) c FROM checklist_items")?.c ?? 0;
  res.json({ tasks, checklists, items });
});

app.get("/api/admin/health", (_req, res) => {
  const journal = db.pragma("journal_mode", { simple: true }) as unknown as string;
  const user_version = db.pragma("user_version", { simple: true }) as unknown as number;
  const tasks = row<{ c: number }>("SELECT COUNT(*) c FROM tasks")?.c ?? 0;
  const checklists = row<{ c: number }>("SELECT COUNT(*) c FROM checklists")?.c ?? 0;
  const items = row<{ c: number }>("SELECT COUNT(*) c FROM checklist_items")?.c ?? 0;
  res.json({
    ok: true,
    db: { path: RESOLVED_DB, journal_mode: journal, wal: String(journal).toUpperCase().includes("WAL"), schema_version: user_version ?? null },
    counts: { tasks, checklists, items },
    ts: new Date().toISOString(),
  });
});

// (exports/backup/vacuum/reindex/clear routes can be re-added if needed)

/* === SECTION: Renown & Rewards
---------------------------------------------------- */
app.get("/api/renown/groups", (_req, res) => {
  const rows = db.prepare("SELECT * FROM renown_groups ORDER BY name").all();
  res.json(rows);
});

app.post("/api/renown/groups", (req, res) => {
  const { name } = req.body;
  db.prepare("INSERT OR IGNORE INTO renown_groups (name) VALUES (?)").run(name);
  res.json({ ok: true });
});

app.post("/api/renown/adjust", (req, res) => {
  const { group_id, delta, note } = req.body;
  const info = db.prepare("INSERT INTO renown_ledger (group_id, delta, note) VALUES (?, ?, ?)").run(group_id, delta, note);
  res.json({ ok: true, ledger_id: info.lastInsertRowid });
});

app.get("/api/renown/summary", (_req, res) => {
  const rows = db
    .prepare(
      `
    SELECT g.group_id, g.name, COALESCE(SUM(l.delta), 0) as total
    FROM renown_groups g
    LEFT JOIN renown_ledger l ON g.group_id = l.group_id
    GROUP BY g.group_id, g.name
  `
    )
    .all();
  res.json(rows);
});

app.get("/api/rewards/earned", (_req, res) => {
  const rows = db.prepare("SELECT * FROM reward_grants ORDER BY created_at DESC").all();
  res.json(rows);
});

app.post("/api/rewards/grant", (req, res) => {
  const { title, note, deltas, source_type, source_id } = req.body;
  const tx = db.transaction(() => {
    // --- journal_entries (ensure table before any use)
    db.exec("CREATE TABLE IF NOT EXISTS journal_entries (entry_id INTEGER PRIMARY KEY, ts TEXT, text TEXT, mood INTEGER, energy INTEGER, stress INTEGER, tags TEXT);");
    db.exec("CREATE INDEX IF NOT EXISTS idx_journal_entries_ts ON journal_entries(ts)");
    // --- journal_entries (ensure table before any use)
// index for date range lookups
    db.exec("CREATE INDEX IF NOT EXISTS idx_journal_entries_ts ON journal_entries(ts)");
    const info = db.prepare("INSERT INTO reward_grants (title, note, source_type, source_id) VALUES (?, ?, ?, ?)").run(title, note, source_type, source_id);
    const grant_id = info.lastInsertRowid;
    if (Array.isArray(deltas)) {
      for (const d of deltas) {
        db.prepare("INSERT INTO reward_grant_deltas (grant_id, group_id, delta) VALUES (?, ?, ?)").run(grant_id, d.group_id, d.delta);
        db.prepare("INSERT INTO renown_ledger (group_id, delta, note) VALUES (?, ?, ?)").run(d.group_id, d.delta, title);
      }
    }
    return grant_id;
  });
  const grant_id = tx();
  res.json({ ok: true, grant_id });
});

/* === SECTION: Chat (LM Studio via adapter_lm.ts)
---------------------------------------------------- */
function buildSystemFromContext(agent: string, context: string): string {
  const pre = `You are ${agent || "Assistant"}, a concise, helpful copilot for a personal productivity app. Prefer short, actionable answers.`;
  const ctx = context && context.trim() ? `\n\nContext:\n${context.trim()}` : "";
  return pre + ctx;
}

app.post("/api/chat", async (req, res) => {
  try {
    const { message = "", agent = "Assistant", model = "lmstudio", context = "" } = req.body || {};
    const system = buildSystemFromContext(agent, context);
    const reply = await chatOnce({ message, system, model });
    res.json({ reply });
  } catch (err: any) {
    res.status(500).json({ error: String(err?.message ?? err) });
  }
});

/* === SECTION: CHAT (SSE stream) ========================================== */
import { stream as lmStream } from "./adapter_lm.ts"; // uses your existing adapter_lm.ts

app.get("/api/chat/stream", async (req, res) => { const DEBUG_STREAM=true;
  // SSE headers
  res.setHeader("Content-Type", "text/event-stream");
  res.setHeader("Cache-Control", "no-cache, no-transform");
  res.setHeader("Connection", "keep-alive");

  const message = String(req.query.message ?? "");
  const agent   = String(req.query.agent ?? "Assistant");
  const model   = String(req.query.model ?? "default");
  const context = String(req.query.context ?? "");

  // Build a simple prompt envelope (you can refine per-agent later)
  const prompt = [
    `### Agent: ${agent}`,
    `### Instructions: You can output plain text, and when you need to act, emit JSON lines like:`,
    `{"type":"toolcall","name":"tasks.create","args":{"title":"..."}}`,
    `I may reply with {"type":"toolresult",...} — then continue your answer.`,
    `### Context:\n${context}`,
    `### User:\n${message}`,
  ].join("\n\n");

  const send = (chunk: string) => res.write(`data: ${chunk}\n\n`);
  const end  = () => { res.write("data: [[END]]\n\n"); res.end(); };

  try {
    // adapter_lm.stream must yield text tokens OR JSON toolcalls as strings
    for await (const piece of lmStream({ prompt, model })) { if (DEBUG_STREAM) { try { console.log('[sse]', typeof piece === 'string' ? piece.slice(0,120) : String(piece)); } catch {} }
      // try to detect toolcall JSON
      let payload: any = null;
      if (typeof piece === "string") {
        const s = piece.trim();
        if ((s.startsWith("{") && s.endsWith("}")) || s.startsWith('{"type":"toolcall"')) {
          try { payload = JSON.parse(s); } catch { /* not JSON, stream as text */ }
        }
      }

      if (payload && payload.type === "toolcall" && payload.name) {
        const result = execTool(payload.name, payload.args ?? {});
        // feed tool result back to the model as a toolresult envelope
        send(JSON.stringify({ type: "toolresult", name: payload.name, ...result }));
        continue;
      }

      // normal text token
      send(typeof piece === "string" ? piece : String(piece));
    }
  } catch (e:any) {
    send(`[error] ${e?.message ?? e}`);
  } finally {
    end();
  }
});


app.get("/api/chat/stream", async (req, res) => { const DEBUG_STREAM=true;
  try {
    const message = String(req.query.message ?? "");
    const agent = String(req.query.agent ?? "Assistant");
    const model = String(req.query.model ?? "lmstudio");
    const context = String(req.query.context ?? "");
    const system = buildSystemFromContext(agent, context);

    res.setHeader("Content-Type", "text/event-stream");
    res.setHeader("Cache-Control", "no-cache");
    res.setHeader("Connection", "keep-alive");

    let closed = false;
    req.on("close", () => {
      closed = true;
      try {
        res.end();
      } catch {}
    });

    await chatStream({
      message,
      system,
      model,
      onChunk: (t: string) => {
        if (!closed) res.write(`data: ${t}\n`);
      },
    });

    if (!closed) {
      res.write("data: [[END]]\n\n");
      res.end();
    }
  } catch (err: any) {
    try {
      res.write(`data: [ERROR] ${String(err?.message ?? err)}\n\ndata: [[END]]\n\n`);
    } catch {}
    res.end();
  }
});

// === SECTION: start
app.listen(PORT, () => {
  console.log(`API listening on http://127.0.0.1:${PORT}`);
});

/* === RUNBOOK (admin) — smoke tests ==========================================
- GET  /api/admin/info
- GET  /api/admin/counts
- GET  /api/admin/health
- GET  /api/task-categories
- GET  /api/tasks
- GET  /api/checklists
- GET  /healthz
============================================================================= */









